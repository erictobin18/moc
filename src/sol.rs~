use geo;
use flu;

pub struct Solution {
    nodes: Vec<Node>,
    bounds: Vec<Boundary>,
    plus_char: Vec<CharLine>,
    minus_char: Vec<CharLine>,
    n: usize,
    stag_p: f64,
    stag_t: f64,
}

impl Solution {
    pub fn new(bounds:Vec<Boundary>, stag_p:f64, stag_t:f64, num_init_nodes:usize) -> Solution {

        let mut node_vec:Vec<Node> = Vec::with_capacity(num_init_nodes);
        let mut pos_vec:Vec<CharLine> = Vec::with_capacity(num_init_nodes);
        let mut neg_vec:Vec<CharLine> = Vec::with_capacity(num_init_nodes);
        for i in 0..num_init_nodes {
            // for now, assume that the init line is vertical with a vertex at 0,0, the other vertex at the r-value of the last point in its path, and (m & th) constant and equal to the first value in their vectors
            node_vec.push( Node {
                
            } );
            pos_vec.push( CharLine {
                
            } );
            neg_vec.push( CharLine {
                
            } );
        }
        
        Solution {
            nodes: node_vec,
            bounds: bounds,
            plus_char: pos_vec,
            minus_char: neg_vec,
            n: num_init_nodes - 1,
            stag_p: stag_p,
            stag_t: stag_t,
    }
    
    pub fn node_at(&self, plus:usize, minus:usize) -> &Node {
        if plus+self.n < minus || plus > minus+self.n || plus+minus < self.n { panic!() } // solution domain
        if minus + 1 > self.minus_char.len() { panic!() }
        &self.nodes[self.minus_char[minus].get_node_at_index(plus)]
    }
    #[allow(unused_variables,dead_code)]
    pub fn update_char(is_plus:bool, index:usize) {
        
    }
    pub fn solve(&mut self) {
        self.n = self.nodes.len() - 1; // nodes[n] is in bounds
        self.minus_char = Vec::with_capacity(self.n);
        self.plus_char = Vec::with_capacity(2*self.n + 1);
        let mut current_index:usize;
        
        println!("Begin for loop!");
        // initial line
        for j in 1..self.n+1 { // count from 1 to n-1, inclusive
            current_index = self.nodes.len();
            println!("Current index is {}",current_index);
            // j is the char_number of the - characteristic
            println!("Begin inner loop!");
            for i in (self.n-j+1)..(self.n+j) { // i is the + char #
                println!("i: {}, j: {}",i,j);
                // create the node representing the intersection between the (+,-) characteristic (i,j)
                let new_node = flu::find_node(self.node_at(i,j-1),self.node_at(i-1,j));
                self.nodes.push(new_node);
            }
            println!("End of inner for loop!");
            // Centerline boundary node
            let new_node = flu::find_node_bnd_pls(self.node_at(self.n+j-1,j));
            self.nodes.push(new_node);
            
            // create the - CharLine
            panic!(); // need to update lines, not add them
            let temp_iter = current_index..self.nodes.len();
            let temp_vec = (j..j+1).chain(temp_iter).collect::<Vec<usize>>();
            
            self.minus_char.push(CharLine {
                is_plus_char:false,
                char_num: j,
                nodes: temp_vec,
                integration_const:0.0,
                path: geo::Path::new(self.nodes.iter().map(|x| x.pos).collect::<Vec<geo::Point>>()),
                char_index_offset: self.n-j,
            });
        }
        println!("End of for loop!");
        self.plus_char = (0..2*self.n + 1).map(|x| {
            CharLine {
                is_plus_char:true,
                char_num: x,
                nodes: (if x < self.n {0} else {x - self.n}..x+1).map(|i| { //SWAGGY RUST RIGHT HEAR
                    if i == 0 { x }
                    else if self.n + i == x {
                        self.n + i
                    }
                    else {
                        self.n + (self.n + i - x)*(self.n + i - x - 1) + i
                    }
                } ).collect::<Vec<usize>>(),

                integration_const:0.0,
                path: geo::Path::new(self.nodes.iter().map(|x| x.pos).collect::<Vec<geo::Point>>()),
                char_index_offset: if x < self.n {self.n - x} else {x - self.n},
            }
        } ).collect::<Vec<CharLine>>();
        println!("End of Solve!");
    }
}

pub struct Node {
    // container for all data associated with an intersection of a + and a - characteristic line
    pub pos: geo::Point,
    pub plus: usize,
    pub minus: usize,
    pub state: flu::FluidState,
    pub is_boundary_node: bool,
}

impl geo::HasLocation for Node {
    fn location(&self) -> geo::Point {
        self.pos
    }
}

#[allow(dead_code)]
pub struct CharLine {
    // a + or a - characteristic line
    is_plus_char: bool,
    char_num: usize,
    nodes: Vec<usize>,
    integration_const: f64,
    path: geo::Path,
    char_index_offset: usize,
}

impl CharLine {
    fn get_node_at_index(&self, other_char:usize) -> usize {
        // get the node at intersection with other_char
        
        // first, determine the char number that goes through the first node in self                
        self.nodes[other_char - self.char_index_offset]        
    }
}

#[allow(dead_code)]
pub enum Boundary {
    SymmetryAxis { point_a: Point, point_b: Point },
    Wall { path: geo::Path },
    InitialLine {
        path:geo::Path,
        m: Vec<f64>,
        th: Vec<f64>
    },
    Outlet { path: geo::Path },
}
